---
layout: post
title: Practica 2 - Basic Vacuum Cleaner
---

# Firsts attempts

time: 150 seconds/lap
# Second attempts

time: 135 seconds/lap

```python
from GUI import GUI
from HAL import HAL
import cv2
import numpy as np
# Enter sequential code!
boundaries = [ ([15, 15, 200], [50, 50, 255]) ]
lin_speed = 6
def clamp(n, min, max):
    if n < min:
        return min
    elif n > max:
        return max
    else:
        return n

class PID:
  def __init__(self, min_ref, max_ref, min_output, max_output):
      self.min_ref_ = min_ref
      self.max_ref_ = max_ref
      self.min_output_ = min_output
      self.max_output_ = max_output
      self.prev_error_ = self.int_error_ = 0.0
    
      self.KP_ = 0.41
      self.KI_ = 0.06
      self.KD_ = 0.53
  
  def setPid(self, n_KP, n_KI, n_KD):
      self.KP_ = n_KP
      self.KI_ = n_KI
      self.KD_ = n_KD
  
  def getOutput(self, new_reference):
    ref = new_reference
    output = 0.0
  
    # Proportional Error
    direction = 0.0
    if ref != 0.0:
      direction = ref / abs(ref)
  
    if abs(ref) < self.min_ref_ :
      output = 0.0
    elif abs(ref) > self.max_ref_:
      output = direction * self.max_output_
    else:
      output = direction * self.min_output_ + ref * (self.max_output_ - self.min_output_)
  
    # Integral Error
    self.int_error_ = (self.int_error_ + output) * 2.0 / 3.0
  
    # Derivative Error
    deriv_error = output - self.prev_error_
    self.prev_error_ = output
  
    output = self.KP_ * output + self.KI_ * self.int_error_ + self.KD_ * deriv_error
  
    return clamp(output / self.max_ref_, -self.max_output_, self.max_output_)

pid = PID(-320,320,-1.5,1.5)
pid.setPid(0.3,0.05,0.6)
while True:
  
    # Enter iterative code!
    # define the list of boundaries
    image = HAL.getImage()
    w = image.shape[1]
    print("Width: ", w)
    for (lower, upper) in boundaries:
    	# create NumPy arrays from the boundaries
    	lower = np.array(lower, dtype = "uint8")
    	upper = np.array(upper, dtype = "uint8")
    	# find the colors within the specified boundaries and apply
    	# the mask
    	mask = cv2.inRange(image, lower, upper)
    	output = cv2.bitwise_and(image, image, mask = mask)
    	# show the images
    	
    	grayImage = cv2.cvtColor(output, cv2.COLOR_BGR2GRAY)
    	ret, thresh = cv2.threshold(grayImage, 50, 255, cv2.THRESH_BINARY)
    	contours, hierarchy = cv2.findContours(thresh, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)
    	cv2.drawContours(output, contours, 0, (0,255,0), 2)
    	M = cv2.moments(contours[0])
    	if M['m00'] == 0:
    	  center_x = 0
    	  center_y = 0
    	else:
    	  center_x = round(M['m10']/M['m00'])
    	  center_y = round(M['m01']/M['m00'])
    	cv2.circle(output, (center_x, center_y),5,(0,255,0),-1)
    	
    	GUI.showImage(np.hstack([image, output]))
    HAL.setW(pid.getOutput(320 - center_x))
    if 320 - center_x > 100 or 320 - center_x < -100:
      lin_speed -= 0.1
    else:
      lin_speed += 0.01
    if lin_speed < 3:
      lin_speed = 3
    elif lin_speed > 6:
      lin_speed = 6
    HAL.setV(lin_speed)
```

# Third attempt

time: 113 seconds/lap

```python
from GUI import GUI
from HAL import HAL
import cv2
import numpy as np
# Enter sequential code!
boundaries = [ ([15, 15, 200], [50, 50, 255]) ]
lin_speed = 4
def clamp(n, min, max):
    if n < min:
        return min
    elif n > max:
        return max
    else:
        return n

class PID:
  def __init__(self, min_ref, max_ref, min_output, max_output):
      self.min_ref_ = min_ref
      self.max_ref_ = max_ref
      self.min_output_ = min_output
      self.max_output_ = max_output
      self.prev_error_ = self.int_error_ = 0.0
    
      self.KP_ = 0.41
      self.KI_ = 0.06
      self.KD_ = 0.53
  
  def setPid(self, n_KP, n_KI, n_KD):
      self.KP_ = n_KP
      self.KI_ = n_KI
      self.KD_ = n_KD
  
  def getOutput(self, new_reference):
    ref = new_reference
    output = 0.0
  
    # Proportional Error
    direction = 0.0
    if ref != 0.0:
      direction = ref / abs(ref)
  
    if abs(ref) < self.min_ref_ :
      output = 0.0
    elif abs(ref) > self.max_ref_:
      output = direction * self.max_output_
    else:
      output = direction * self.min_output_ + ref * (self.max_output_ - self.min_output_)
  
    # Integral Error
    self.int_error_ = (self.int_error_ + output) * 2.0 / 3.0
  
    # Derivative Error
    deriv_error = output - self.prev_error_
    self.prev_error_ = output
  
    output = self.KP_ * output + self.KI_ * self.int_error_ + self.KD_ * deriv_error
  
    return clamp(output / self.max_ref_, -self.max_output_, self.max_output_)

pid = PID(-320,320,-1,1)
pid.setPid(0.46,0.05,1.3)
while True:
  
    # Enter iterative code!
    # define the list of boundaries
    image = HAL.getImage()
    w = image.shape[1]
    print("Width: ", w)
    for (lower, upper) in boundaries:
    	# create NumPy arrays from the boundaries
    	lower = np.array(lower, dtype = "uint8")
    	upper = np.array(upper, dtype = "uint8")
    	# find the colors within the specified boundaries and apply
    	# the mask
    	mask = cv2.inRange(image, lower, upper)
    	output = cv2.bitwise_and(image, image, mask = mask)
    	# show the images
    	
    	grayImage = cv2.cvtColor(output, cv2.COLOR_BGR2GRAY)
    	ret, thresh = cv2.threshold(grayImage, 50, 255, cv2.THRESH_BINARY)
    	contours, hierarchy = cv2.findContours(thresh, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)
    	cv2.drawContours(output, contours, 0, (0,255,0), 2)
    	M = cv2.moments(contours[0])
    	if M['m00'] == 0:
    	  center_x = 0
    	  center_y = 0
    	else:
    	  center_x = round(M['m10']/M['m00'])
    	  center_y = round(M['m01']/M['m00'])
    	cv2.circle(output, (center_x, center_y),5,(0,255,0),-1)
    	
    	GUI.showImage(np.hstack([image, output]))
    HAL.setW(pid.getOutput(320 - center_x))
    #if 320 - center_x > 100 or 320 - center_x < -100:
    #  lin_speed -= 0.1
    #else:
    #  lin_speed += 0.01
    #if lin_speed < 4:
    #  lin_speed = 4
    #elif lin_speed > 6:
    #  lin_speed = 6
    print("Speed: ", lin_speed)
    HAL.setV(lin_speed)
```
# Two PID

time: 115 lap

```python
from GUI import GUI
from HAL import HAL
import cv2
import numpy as np
# Enter sequential code!
boundaries = [ ([15, 15, 200], [50, 50, 255]) ]
lin_speed = 4
def clamp(n, min, max):
    if n < min:
        return min
    elif n > max:
        return max
    else:
        return n

class PID:
  def __init__(self, min_ref, max_ref, min_output, max_output):
      self.min_ref_ = min_ref
      self.max_ref_ = max_ref
      self.min_output_ = min_output
      self.max_output_ = max_output
      self.prev_error_ = self.int_error_ = 0.0
    
      self.KP_ = 0.41
      self.KI_ = 0.06
      self.KD_ = 0.53
  
  def setPid(self, n_KP, n_KI, n_KD):
      self.KP_ = n_KP
      self.KI_ = n_KI
      self.KD_ = n_KD
  
  def getOutput(self, new_reference):
    ref = new_reference
    output = 0.0
  
    # Proportional Error
    direction = 0.0
    if ref != 0.0:
      direction = ref / abs(ref)
  
    if abs(ref) < self.min_ref_ :
      output = 0.0
    elif abs(ref) > self.max_ref_:
      output = direction * self.max_output_
    else:
      output = direction * self.min_output_ + ref * (self.max_output_ - self.min_output_)
  
    # Integral Error
    self.int_error_ = (self.int_error_ + output) * 2.0 / 3.0
  
    # Derivative Error
    deriv_error = output - self.prev_error_
    self.prev_error_ = output
  
    output = self.KP_ * output + self.KI_ * self.int_error_ + self.KD_ * deriv_error
  
    return clamp(output / self.max_ref_, -self.max_output_, self.max_output_)

pid = PID(-320,320,-1,1)
pid.setPid(0.46,0.05,1.3)
pid2 = PID(0,320,3,8)
pid2.setPid(0.5,0.5,1)
while True:
  
    # Enter iterative code!
    # define the list of boundaries
    image = HAL.getImage()
    w = image.shape[0]
    print("Width: ", w)
    for (lower, upper) in boundaries:
    	# create NumPy arrays from the boundaries
    	lower = np.array(lower, dtype = "uint8")
    	upper = np.array(upper, dtype = "uint8")
    	# find the colors within the specified boundaries and apply
    	# the mask
    	mask = cv2.inRange(image, lower, upper)
    	output = cv2.bitwise_and(image, image, mask = mask)
    	# show the images
    	
    	grayImage = cv2.cvtColor(output, cv2.COLOR_BGR2GRAY)
    	ret, thresh = cv2.threshold(grayImage, 50, 255, cv2.THRESH_BINARY)
    	contours, hierarchy = cv2.findContours(thresh, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)
    	cv2.drawContours(output, contours, 0, (0,255,0), 2)
    	M = cv2.moments(contours[0])
    	if M['m00'] == 0:
    	  center_x = 0
    	  center_y = 0
    	else:
    	  center_x = round(M['m10']/M['m00'])
    	  center_y = round(M['m01']/M['m00'])
    	cv2.circle(output, (center_x, center_y),5,(0,255,0),-1)
    	print("Vert: ", center_y)
    	
    	GUI.showImage(np.hstack([image, output]))
    HAL.setW(pid.getOutput(320 - center_x))
    #if 320 - center_x > 100 or 320 - center_x < -100:
    #  lin_speed -= 0.1
    #else:
    #  lin_speed += 0.01
    #if lin_speed < 4:
    #  lin_speed = 4
    #elif lin_speed > 6:
    #  lin_speed = 6
    #print("Speed: ", pid2.getOutput(center_y))
    print("Speed: ", pid2.getOutput(320 - abs(320 - center_x)),320 - abs(320 - center_x) )
    HAL.setV(pid2.getOutput(320 - abs(320 - center_x)))
```

# Two PID 2

time: 105 lap

```python
from GUI import GUI
from HAL import HAL
import cv2
import numpy as np
# Enter sequential code!
boundaries = [ ([15, 15, 200], [50, 50, 255]) ]
lin_speed = 4
def clamp(n, min, max):
    if n < min:
        return min
    elif n > max:
        return max
    else:
        return n

class PID:
  def __init__(self, min_ref, max_ref, min_output, max_output):
      self.min_ref_ = min_ref
      self.max_ref_ = max_ref
      self.min_output_ = min_output
      self.max_output_ = max_output
      self.prev_error_ = self.int_error_ = 0.0
    
      self.KP_ = 0.41
      self.KI_ = 0.06
      self.KD_ = 0.53
  
  def setPid(self, n_KP, n_KI, n_KD):
      self.KP_ = n_KP
      self.KI_ = n_KI
      self.KD_ = n_KD
  
  def getOutput(self, new_reference):
    ref = new_reference
    output = 0.0
  
    # Proportional Error
    direction = 0.0
    if ref != 0.0:
      direction = ref / abs(ref)
  
    if abs(ref) < self.min_ref_ :
      output = 0.0
    elif abs(ref) > self.max_ref_:
      output = direction * self.max_output_
    else:
      output = direction * self.min_output_ + ref * (self.max_output_ - self.min_output_)
  
    # Integral Error
    self.int_error_ = (self.int_error_ + output) * 2.0 / 3.0
  
    # Derivative Error
    deriv_error = output - self.prev_error_
    self.prev_error_ = output
  
    output = self.KP_ * output + self.KI_ * self.int_error_ + self.KD_ * deriv_error
  
    return clamp(output / self.max_ref_, -self.max_output_, self.max_output_)

pid = PID(-320,320,-1,1)
pid.setPid(0.34,0,1.64)
pid2 = PID(0,320,3,9)
pid2.setPid(0.7,0.2,1)
while True:
  
    # Enter iterative code!
    # define the list of boundaries
    image = HAL.getImage()
    w = image.shape[0]
    print("Width: ", w)
    for (lower, upper) in boundaries:
    	# create NumPy arrays from the boundaries
    	lower = np.array(lower, dtype = "uint8")
    	upper = np.array(upper, dtype = "uint8")
    	# find the colors within the specified boundaries and apply
    	# the mask
    	mask = cv2.inRange(image, lower, upper)
    	output = cv2.bitwise_and(image, image, mask = mask)
    	# show the images
    	
    	grayImage = cv2.cvtColor(output, cv2.COLOR_BGR2GRAY)
    	ret, thresh = cv2.threshold(grayImage, 50, 255, cv2.THRESH_BINARY)
    	contours, hierarchy = cv2.findContours(thresh, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)
    	cv2.drawContours(output, contours, 0, (0,255,0), 2)
    	M = cv2.moments(contours[0])
    	if M['m00'] == 0:
    	  center_x = 0
    	  center_y = 0
    	else:
    	  center_x = round(M['m10']/M['m00'])
    	  center_y = round(M['m01']/M['m00'])
    	cv2.circle(output, (center_x, center_y),5,(0,255,0),-1)
    	print("Vert: ", center_y)
    	
    	GUI.showImage(np.hstack([image, output]))
    HAL.setW(pid.getOutput(320 - center_x))
    #if 320 - center_x > 100 or 320 - center_x < -100:
    #  lin_speed -= 0.1
    #else:
    #  lin_speed += 0.01
    #if lin_speed < 4:
    #  lin_speed = 4
    #elif lin_speed > 6:
    #  lin_speed = 6
    #print("Speed: ", pid2.getOutput(center_y))
    print("Speed: ", pid2.getOutput(320 - abs(320 - center_x)),320 - abs(320 - center_x) )
    HAL.setV(pid2.getOutput(320 - abs(320 - center_x)))
```

# Cropped image

time: 97 lap
```python
from GUI import GUI
from HAL import HAL
import cv2
import numpy as np
# Enter sequential code!
boundaries = [ ([15, 15, 200], [50, 50, 255]) ]
lin_speed = 4
def clamp(n, min, max):
    if n < min:
        return min
    elif n > max:
        return max
    else:
        return n

class PID:
  def __init__(self, min_ref, max_ref, min_output, max_output):
      self.min_ref_ = min_ref
      self.max_ref_ = max_ref
      self.min_output_ = min_output
      self.max_output_ = max_output
      self.prev_error_ = self.int_error_ = 0.0
    
      self.KP_ = 0.41
      self.KI_ = 0.06
      self.KD_ = 0.53
  
  def setPid(self, n_KP, n_KI, n_KD):
      self.KP_ = n_KP
      self.KI_ = n_KI
      self.KD_ = n_KD
  
  def getOutput(self, new_reference):
    ref = new_reference
    output = 0.0
  
    # Proportional Error
    direction = 0.0
    if ref != 0.0:
      direction = ref / abs(ref)
  
    if abs(ref) < self.min_ref_ :
      output = 0.0
    elif abs(ref) > self.max_ref_:
      output = direction * self.max_output_
    else:
      output = direction * self.min_output_ + ref * (self.max_output_ - self.min_output_)
  
    # Integral Error
    self.int_error_ = (self.int_error_ + output) * 2.0 / 3.0
  
    # Derivative Error
    deriv_error = output - self.prev_error_
    self.prev_error_ = output
  
    output = self.KP_ * output + self.KI_ * self.int_error_ + self.KD_ * deriv_error
  
    return clamp(output / self.max_ref_, -self.max_output_, self.max_output_)

pid = PID(-320,320,-1,1)
pid.setPid(0.36,0,1.67)
pid2 = PID(0,320,3,9)
pid2.setPid(0.8,0.2,1)
while True:
  
    # Enter iterative code!
    # define the list of boundaries
    img = HAL.getImage()
    image = img[200:400, 0:640]
    for (lower, upper) in boundaries:
    	# create NumPy arrays from the boundaries
    	lower = np.array(lower, dtype = "uint8")
    	upper = np.array(upper, dtype = "uint8")
    	# find the colors within the specified boundaries and apply
    	# the mask
    	mask = cv2.inRange(image, lower, upper)
    	output = cv2.bitwise_and(image, image, mask = mask)
    	# show the images
    	
    	grayImage = cv2.cvtColor(output, cv2.COLOR_BGR2GRAY)
    	ret, thresh = cv2.threshold(grayImage, 50, 255, cv2.THRESH_BINARY)
    	contours, hierarchy = cv2.findContours(thresh, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)
    	cv2.drawContours(output, contours, 0, (0,255,0), 2)
    	M = cv2.moments(contours[0])
    	if M['m00'] == 0:
    	  center_x = 0
    	  center_y = 0
    	else:
    	  center_x = round(M['m10']/M['m00'])
    	  center_y = round(M['m01']/M['m00'])
    	cv2.circle(output, (center_x, center_y),5,(0,255,0),-1)
    	print("Vert: ", center_y)
    	
    	GUI.showImage(np.hstack([image, output]))
    HAL.setW(pid.getOutput(320 - center_x))
    print("Speed: ", pid2.getOutput(320 - abs(320 - center_x)),320 - abs(320 - center_x) )
    HAL.setV(pid2.getOutput(320 - abs(320 - center_x)))
```

# Tweaking values

time: 87 lap for 5 laps in 445 sec

```python
from GUI import GUI
from HAL import HAL
import cv2
import numpy as np
# Enter sequential code!
boundaries = [ ([15, 15, 200], [50, 50, 255]) ]
lin_speed = 4
def clamp(n, min, max):
    if n < min:
        return min
    elif n > max:
        return max
    else:
        return n

class PID:
  def __init__(self, min_ref, max_ref, min_output, max_output):
      self.min_ref_ = min_ref
      self.max_ref_ = max_ref
      self.min_output_ = min_output
      self.max_output_ = max_output
      self.prev_error_ = self.int_error_ = 0.0
    
      self.KP_ = 0.41
      self.KI_ = 0.06
      self.KD_ = 0.53
  
  def setPid(self, n_KP, n_KI, n_KD):
      self.KP_ = n_KP
      self.KI_ = n_KI
      self.KD_ = n_KD
  
  def getOutput(self, new_reference):
    ref = new_reference
    output = 0.0
  
    # Proportional Error
    direction = 0.0
    if ref != 0.0:
      direction = ref / abs(ref)
  
    if abs(ref) < self.min_ref_ :
      output = 0.0
    elif abs(ref) > self.max_ref_:
      output = direction * self.max_output_
    else:
      output = direction * self.min_output_ + ref * (self.max_output_ - self.min_output_)
  
    # Integral Error
    self.int_error_ = (self.int_error_ + output) * 2.0 / 3.0
  
    # Derivative Error
    deriv_error = output - self.prev_error_
    self.prev_error_ = output
  
    output = self.KP_ * output + self.KI_ * self.int_error_ + self.KD_ * deriv_error
  
    return clamp(output / self.max_ref_, self.min_output_, self.max_output_)

pid = PID(-320,320,-1,1)
pid.setPid(0.36,0,1.7)
pid2 = PID(0,320,2,9)
pid2.setPid(0.9,0.2,10)
while True:
  
    # Enter iterative code!
    # define the list of boundaries
    img = HAL.getImage()
    image = img[240:360, 0:640]
    for (lower, upper) in boundaries:
    	# create NumPy arrays from the boundaries
    	lower = np.array(lower, dtype = "uint8")
    	upper = np.array(upper, dtype = "uint8")
    	# find the colors within the specified boundaries and apply
    	# the mask
    	mask = cv2.inRange(image, lower, upper)
    output = cv2.bitwise_and(image, image, mask = mask)
  	# show the images
    grayImage = cv2.cvtColor(output, cv2.COLOR_BGR2GRAY)
    ret, thresh = cv2.threshold(grayImage, 50, 255, cv2.THRESH_BINARY)
    contours, hierarchy = cv2.findContours(thresh, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)
    cv2.drawContours(output, contours, 0, (0,255,0), 2)
    if len(contours) > 0:
      M = cv2.moments(contours[0])
      if M['m00'] == 0:
        center_x = 0
        center_y = 0
      else:
        center_x = round(M['m10']/M['m00'])
        center_y = round(M['m01']/M['m00'])
      cv2.circle(output, (center_x, center_y),5,(0,255,0),-1)
    	
      GUI.showImage(np.hstack([image, output]))
      HAL.setW(pid.getOutput(320 - center_x))
      print("Speed: ", pid2.getOutput(320 - abs(320 - center_x)),320 - abs(320 - center_x) )
      HAL.setV(pid2.getOutput(320 - abs(320 - center_x)))
```

# Final

simple tiempo: 71 seconds, 3 vueltas en 214 sec
Simple 2.96
Montmelo 2.96
Nurburring  2.96
Simple a 7 vel y 85 secf
MONTREAL A 7 vel y 242 sec
Nurburring  a 7 vel y 130 sec

<video src="../images/SimpleFinal.mp4" controls title="Title"></video>
<video src="../images/Montmelo.mov" controls title="Title"></video>

```python
from GUI import GUI
from HAL import HAL
import cv2
import numpy as np
# Enter sequential code!
boundaries = [ ([15, 15, 200], [50, 50, 255]) ]
lin_speed = 0
def clamp(n, min, max):
    if n < min:
        return min
    elif n > max:
        return max
    else:
        return n

class PID:
  def __init__(self, min_ref, max_ref, min_output, max_output):
      self.min_ref_ = min_ref
      self.max_ref_ = max_ref
      self.min_output_ = min_output
      self.max_output_ = max_output
      self.prev_error_ = self.int_error_ = 0.0
    
      self.KP_ = 0.41
      self.KI_ = 0.06
      self.KD_ = 0.53
  
  def setPid(self, n_KP, n_KI, n_KD):
      self.KP_ = n_KP
      self.KI_ = n_KI
      self.KD_ = n_KD
  
  def getOutput(self, new_reference):
    ref = new_reference
    output = 0.0
  
    # Proportional Error
    direction = 0.0
    if ref != 0.0:
      direction = ref / abs(ref)
  
    if abs(ref) < self.min_ref_ :
      output = 0.0
    elif abs(ref) > self.max_ref_:
      output = direction * self.max_output_
    else:
      output = direction * self.min_output_ + ref * (self.max_output_ - self.min_output_)
  
    # Integral Error
    self.int_error_ = (self.int_error_ + output) * 2.0 / 3.0
  
    # Derivative Error
    deriv_error = output - self.prev_error_
    self.prev_error_ = output
  
    output = self.KP_ * output + self.KI_ * self.int_error_ + self.KD_ * deriv_error
  
    return clamp(output / self.max_ref_, self.min_output_, self.max_output_)


pid = PID(-320,320,-1,1)
pid.setPid(0.45,0,2.95)
pid2 = PID(0,320,0,9)
pid2.setPid(0.9,0.2,10)
last_lin_speed = 0
while True:
  
    # Enter iterative code!
    # define the list of boundaries
    img = HAL.getImage()
    image = img[240:350, 0:640]
    for (lower, upper) in boundaries:
    	# create NumPy arrays from the boundaries
    	lower = np.array(lower, dtype = "uint8")
    	upper = np.array(upper, dtype = "uint8")
    	# find the colors within the specified boundaries and apply
    	# the mask
    	mask = cv2.inRange(image, lower, upper)
    output = cv2.bitwise_and(image, image, mask = mask)
  	# show the images
    grayImage = cv2.cvtColor(output, cv2.COLOR_BGR2GRAY)
    ret, thresh = cv2.threshold(grayImage, 50, 255, cv2.THRESH_BINARY)
    contours, hierarchy = cv2.findContours(thresh, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)
    cv2.drawContours(output, contours, 0, (0,255,0), 2)
    if len(contours) > 0:
      M = cv2.moments(contours[0])
      if M['m00'] == 0:
        center_x = 0
        center_y = 0
      else:
        center_x = round(M['m10']/M['m00'])
        center_y = round(M['m01']/M['m00'])
      cv2.circle(output, (center_x, center_y),5,(0,255,0),-1)
    	
      HAL.setW(pid.getOutput(320 - center_x))
      lin_speed = (last_lin_speed + pid2.getOutput(320 - abs(320 - center_x))) / 2
      last_lin_speed = pid2.getOutput(320 - abs(320 - center_x))
      HAL.setV(lin_speed)
    GUI.showImage(np.hstack([image, output]))
```